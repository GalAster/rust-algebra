@export
VkParser = {statements:VkStatements} $;

VkStatements =
	@:NamespaceDeclareNode |
	@:ClassStatement |
	@:DefStatement |
	@:LetStatement |
	@:LoopStatement |
	@:WhileStatement |
	@:ForStatement |
	@:IfStatement |
	@:ControlFlowNode |
	@:ExpressionNode |
	@:Semicolon
;

#=======================================================================================================================
NamespaceDeclareNode = kw:KwNamespace namespace:NamepathFree;
@no_skip_ws @string
KwNamespace = "namespace" ['!' | '*'];
#=======================================================================================================================
@position
ClassStatement = "class" namespace:Namepath body:BlockNode;
#=======================================================================================================================
@position
LoopStatement = "loop" body:BlockNode;
@position
WhileStatement = "while" condition:ExpressionNode body:BlockNode [else:ElseStatement];
@position
ForStatement = "for" pattern:PatternNode "in" value:ExpressionNode body:BlockNode [else:ElseStatement];
#=======================================================================================================================
@position
IfStatement = "if" condition:ExpressionNode body:BlockNode [else:ElseStatement];
ElseIfStatement = "else" "if" condition:ExpressionNode body:BlockNode [else:ElseStatement];
ElseStatement = "else" body:BlockNode;
#=======================================================================================================================
DefStatement = "def" namespace:Namepath [parameters:DefineArguments] body:BlockNode;

DefineArguments = '(' ')' | '(' args:DefineArgument [',' args:DefineArgument] ')';
DefineArgument = name:IdentifierNode [':' type:TypeNode] ['=' value:ExpressionNode ];

BlockNode = '{' {statements:VkStatements} '}';


#=======================================================================================================================
LetStatement = "let" {modifiers:Modifier} pattern:PatternNode [':' type:TypeNode] ['=' value:ExpressionNode ];
PatternNode = name:IdentifierNode;

TypeNode = id:IdentifierNode;
#=======================================================================================================================
ControlFlowNode =
	  "break"
	| "continue"
	| "return" [value:ExpressionNode]
	| "raise" value:ExpressionNode
	| "yield" value:ExpressionNode
	| "yield" "from" value:ExpressionNode
	| "yield" "break"
	;
#=======================================================================================================================
@position
ExpressionNode = expr:*ExprNode {infix:ExprInfix};


ExprInfix = infix:InfixOperators expr:ExprNode;


ExprNode = {prefix:Prefix} term:TermNode {suffix:Suffix};


TermNode = '(' @:ExpressionNode ')'
	| @:TupleStatement
	| @:TableStatement
	| @:ListStatement
	| @:StringNode
	| @:SpecialNode
	| @:Namepath
	| @:NumberNode;

@string @position
SpecialNode = 'null' | 'default' | 'true' | 'false';

@string @position
Prefix = '!' | '+' | '-' | '⅟' | '¬'
	;
@string @position
InfixOperators =
	'is' ['not'] | ['not'] 'in' |
	'++=' | '++' | '+=' | '+' |
	'--=' | '--' | '-=' | '-' |
	MULS | DIVS |
	'^=' | '^' |
	'<<=' | '<<<' | '<<' | '<=' | '<' |
	'>>=' | '>>>' | '>>' | '>=' | '>' |
	'==' | '=' |
	'&&' | '∧' | '⊼' | '⩟' | '&' |
	'||' | '∨' | '⊽' | '⊻' | '|' |
	CONTAINS |'⋃' | '⋂'
	;
@string @position
Suffix = '?' | '!' | '%'| '‰'| '‱'| '℃'| '℉' | '°' | '′'| '″' | '‴' | '⁗'
	;
@no_skip_ws
MULS = ('⋆' | '∗' | '*' | '×' | '⨯' | '⨉' | '⊗' | '⨂' | '⋅') ['='];
@no_skip_ws
DIVS = ('/' ) ['='];
@no_skip_ws
CONTAINS = [NOT] ('∋' | '∍' | '∊' | '∈' | '∉' | '∌');
NOT = '!' | '¬';
#=======================================================================================================================
@position
TupleStatement = '('  ')'
	| '(' args:ExpressionNode {',' args:ExpressionNode} [','] ')';
@position
ListStatement = '[' ']'
	| '[' args:ExpressionNode {',' args:ExpressionNode} [','] ']';
@position
TableStatement = '[' ']'
	| '[' args:KeyValueNode {',' args:KeyValueNode} [','] ']';
#=======================================================================================================================
LambdaStatement = "lambda" [parameters:DefineArguments];


#=======================================================================================================================
DotCall = '.' name:IdentifierNode [args:CallArguments];
CallArguments = '(' ')' | '(' args:CallArgument [',' args:CallArgument] ')';
CallArgument = name:IdentifierNode ['=' value:ExpressionNode ];
#=======================================================================================================================
KeyValueNode = key:KeyNode ':' value:ValueNode;

ValueNode =
	@:IntegerNode |
	@:StringNode
;

@position
KeyNode =
	@:IdentifierNode |
	@:StringNode
;
#=======================================================================================================================
@position
StringNode = [hint:IdentifierNode] raw:RawString;
@position
RawString =
	'"' {!'"' item:StringItem} '"' |
	"'" {!"'" item:StringItem} "'";

StringItem =
	@:ESCAPE_U |
	@:ESCAPE_C |
	@:STRING_T |
	@:StringAny;

ESCAPE_C = '\\' char:StringAny;

@position
ESCAPE_U = '\\' 'u' '{' {hex:HEX} '}';


STRING_T = '{' expr:ExpressionNode '}';

@char
StringAny = char;
#=======================================================================================================================
@position
@no_skip_ws
NumberNode = variant:NumberVariant [hint:IdentifierNode];

NumberVariant =
	@:ByteBin |
	@:ByteHex |
	@:DecimalNode |
	@:IntegerNode ;

@string @position @no_skip_ws
IntegerNode = '0' | '1'..'9' { '0'..'9' | '_'};
@string @position @no_skip_ws
DecimalNode = IntegerNode Dot {'0'..'9' | '_'};
@string @position @no_skip_ws
ByteBin = '0' ('b' | 'B') { HEX }+;
@string @position @no_skip_ws
ByteHex = '0' ('x' | 'X') { HEX }+;

@char
HEX = '0'..'9' | 'a'..'f' | 'A'..'F';
#=======================================================================================================================
@position
NamespaceStar = path:IdentifierNode {NamespaceSplit path:IdentifierNode};

@position
Namepath = path:IdentifierNode {NamespaceSplit path:IdentifierNode};

@position
NamepathFree = path:IdentifierNode {(NamespaceSplit|Dot) path:IdentifierNode};

NamespaceSplit = '::';

Modifier = id:IdentifierNode !('('|':'|'.'|'=');

@string
@position
@no_skip_ws
IdentifierNode = (XID_START | '_') {XID_CONTINUE};

@char
@check(unicode_ident::is_xid_start)
XID_START = char;

@char
@check(unicode_ident::is_xid_continue)
XID_CONTINUE = char;

@char
Dot = '.' | '。';


Semicolon = ';';

@char
Split = ';' | ',' | '，';
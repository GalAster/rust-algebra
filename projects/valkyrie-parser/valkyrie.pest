program = _{SOI~statement* ~ EOI}

statement = {
    emptyStatement
  | importStatement ~ eos?
  | classStatement ~ eos?
  | traitStatement ~ eos?
  | extendStatement ~ eos?
  | controlFlow ~ eos?
  | assignStatement ~ eos?
  | defineStatement ~ eos?
  | annotation ~ eos?
  | expression
}
/*====================================================================================================================*/
emptyStatement = {eos}
eos = {Separate|Semicolon}
separator = {eos|Comma}
comma_or_semi = _{Comma|Semicolon}
block_or_stmt = _{block|Set ~ statement}
/*====================================================================================================================*/
importStatement = {
    IMPORT ~ DOT* ~ use_alias
  | IMPORT ~ DOT* ~ use_module_select
  | IMPORT ~ use_module_string
}
use_alias = !{String ~ AS ~ Symbol|Symbol ~ (ModuleSplit ~ Symbol)* ~AS~Symbol}
use_module_select = !{Symbol ~ (ModuleSplit ~ Symbol)* ~(ModuleSplit ~ (module_block|Star))?}
use_module_string = !{String ~ (ModuleSplit ~ (module_block|Star))?}
module_block = {"{" ~ module_tuple ~ ( comma_or_semi? ~ module_tuple)* ~ comma_or_semi? ~ "}"}
module_tuple = {use_alias|use_module_select}
ModuleSplit= _{DOT|Proportion}
//!#C678DD: Import|As
IMPORT = @{"using"}
AS     = @{"as"}
/*====================================================================================================================*/
controlFlow = _{non_local_exit|if_statement|for_statement}
block = !{"{" ~ statement+ ~ "}"}
/*====================================================================================================================*/
if_statement = {if_block ~ else_if_block* ~ else_block?}
if_block = _{If ~ condition ~ block}
else_if_block = _{Else ~ If ~ condition ~ block}
else_block = _{Else ~ block}
//!#C678DD: If|Else
condition = _{"(" ~ expr ~ ")"|expr}
If        = @{"if"}
Else      = @{"else"}
/*====================================================================================================================*/
match_statement = {
    Match ~ expression ~ "{" ~ case_statement+ ~ "}"
}
case_statement = {
    Colon ~ statement
}
Match = @{"match"}
Case = @{"case"}
/*====================================================================================================================*/
//!#C678DD: WHILE|For|In
for_statement = {FOR ~ Symbol ~ IN ~ expr_inline ~ block}
while_statement = {WHILE ~ expr_inline ~ block}
WHILE = @{"while"}
FOR = @{"for"}
IN = @{"in"}
/*====================================================================================================================*/
//!#C678DD: EXIT
non_local_exit = {EXIT ~ expr}
EXIT = @{"return"|"resume"}
//!#C678DD: Return|Yield|Break|Pass
/*====================================================================================================================*/
///#C678DD
Type = @{"type"}
/*====================================================================================================================*/
classStatement = {CLASS ~ assign_pair ~ short_block?}
traitStatement = {TRAIT ~ assign_pair ~ short_block?}

short_block = {"{" ~ short_statement* ~ "}"}
short_statement = {
    emptyStatement
  | "def"? ~ define_terms ~ eos?
    // mut a = 1 ;
  | assign_pair ~ separator?
  | short_annotation ~ eos?
}
short_annotation = {annotation_call+~short_statement}
CLASS = @{"class"}
TRAIT = @{"trait"}
/*====================================================================================================================*/
extendStatement = {
    EXTENDS ~ Symbol ~ parametric_types? ~ with_trait? ~ short_block
}
with_trait = {"with" ~ Symbol ~ parametric_types?}
EXTENDS = @{"extends"}
/*====================================================================================================================*/
assignStatement = {
    // let (mut a: int, ) = 1;
    LET ~ "(" ~ assign_name ~ ")" ~ type_hint? ~ Set ~ expr ~ eos?
    // let (a: int, b: int)
    // let (a, b): (int, int)
  | LET ~ "(" ~ assign_name ~ ")" ~ type_hint? ~ eos?
    // let mut a: int, = 1;
  | LET ~ assign_name ~ Set ~ expr ~ eos?
    // let a, b: int;
  | LET ~ assign_name ~ eos
  | LET ~ short_statement ~ eos?
}
assign_name = _{assign_pair ~ (Comma ~ assign_pair)* ~ Comma?}
assign_pair = {Modifier* ~ Symbol ~ type_hint?}

///#C678DD
LET = @{"let"}
/*====================================================================================================================*/
defineStatement = {"def" ~ define_terms}
define_terms = _{
    assign_pair ~ parametric_types ~ define_parameter ~ type_hint? ~ parametric_types_term? ~ block_or_stmt?
  | assign_pair ~ define_parameter ~ type_hint? ~ block_or_stmt?
}
define_parameter = {
    "(" ~ define_pair ~ (Comma ~ define_pair)* ~ Comma? ~ ")"
  | "(" ~ ")"
}
define_pair = {Symbol ~ type_hint? ~ (Set ~ expr)?}
//!#C678DD: Def|Where
Where = @{"where"}
/*====================================================================================================================*/
//!Orange:annotation_call
annotation      = {annotation_call+~statement}
annotation_call = @{Sharp~(apply|Symbol)}
macro_call      = @{At ~(apply|Symbol) }
Sharp =@{"#"}
At    =@{"@"}
/*====================================================================================================================*/
expression = {expr ~ eos?}
expr       = {term ~ (Infix ~ term)*}
term       = {Prefix* ~ node ~ Suffix*}
node       = {
    "(" ~ expr ~ ")"
  | data ~ bracket_once? ~ (bracket_call+ ~ bracket_once?)+
  | data
}
expr_inline  = {term_inline ~ (Infix ~ term_inline)*}
term_inline  = {Prefix* ~ node_inline ~ Suffix*}
node_inline  = {
    "(" ~ expr ~ ")"
  | data ~ bracket_call*
}
bracket_call = _{dot_call|static_call|slice|apply|generic_call}
bracket_once = _{block}
dot_call     =  {DOT ~ (Integer|namepath) }
static_call  =  {"::" ~ namepath}
generic_call = !{"::" ~ generic_type}
/*====================================================================================================================*/
apply           = !{"(" ~ ")" | "(" ~ apply_kv ~ (Comma ~ apply_kv)* ~ Comma? ~")"}
apply_kv        =  {Symbol~ Colon ~ expr | expr}
///#61AFEF
function_name   = {Symbol}
function_module = {(namepath ~ DOT)? ~ (Symbol ~ DOT)*}
/*====================================================================================================================*/
//!#E06C75: type_hint|generic_type|parametric_types_pair
type_expr = _{term ~ (TypeInfix ~ term)*}
//type_term = {Prefix* ~ type_node ~ Suffix*}
//type_node = {"(" ~ type_expr ~ ")"|data}
type_hint = {Colon ~ type_expr}
generic_type = {"[" ~ expr ~ (Comma ~ expr)* ~ Comma? ~ "]"}
parametric_types = {"[" ~ parametric_types_pair ~ (Comma ~ parametric_types_pair)* ~ "]"}
parametric_types_pair = {(ADD|SUB)? ~ Symbol}
parametric_types_term = {Where ~ (expr ~ Colon ~ expr ~ eos?)+}
//TypePrefix = @{Plus|Minus}
//TypeSuffix = @{Question}
TypeInfix = @{Or}
/*====================================================================================================================*/
data        =  {tuple|table|block|Special|Byte|Complex|Decimal|Integer|String|namepath}
tuple       =  {"(" ~ ")" | "(" ~ expr ~ (Comma ~ expr)* ~ Comma? ~ ")"}
table       =  {"[" ~ "]" | "[" ~ table_item? ~ (Comma ~ table_item)* ~ Comma? ~ "]"}
table_item  = _{table_pair|expr}
table_pair  =  {valid_key ~ Colon ~ expr}
valid_key   = _{Integer | Symbol | String}
/*====================================================================================================================*/
slice       =  {"[" ~ index ~ (Comma ~ index)* ~ Comma? ~ "]"}
index       =  {index_step|index_range|expr}
index_range =  {expr? ~ Colon ~ expr?}
index_step  =  {expr? ~ Colon ~ expr? ~ Colon ~ expr?}
/*====================================================================================================================*/
//!#D19A66: Integer|Decimal|DecimalBad|Byte
//!#D19A66: Special
Byte    = ${Zero ~ ASCII_ALPHA ~ (Underline|SUB|ASCII_ALPHANUMERIC)+}
Decimal = ${Integer ~ DOT ~ Integer+}
// DecimalBad = ${Integer ~ Dot|Dot ~ Integer+}
Integer = @{Zero|ASCII_NONZERO_DIGIT ~ (Underline|ASCII_DIGIT)*}
Complex = ${(Decimal|Integer) ~ Symbol}
Zero    = _{"0"}
Special = !{"true" | "false"}
Underline = _{"_"}
/*====================================================================================================================*/
// https://en.wikipedia.org/wiki/Quotation_mark#Summary_table
///#98C379
String         = ${
    Symbol? ~ PUSH(Quotation{3,}|Apostrophe{3,}|Quotation|Apostrophe) ~ (StringItem|!PEEK ~ any)* ~ POP |
    Symbol? ~"『" ~ (StringItem|!"』" ~ any)* ~ "』" |
    Symbol? ~"「" ~ (StringItem|!"」" ~ any)* ~ "」" |
    Symbol? ~"«" ~ (StringItem|!"»" ~ any)* ~ "»" |
    Symbol? ~"‹" ~ (StringItem|!"›" ~ any)* ~ "›"
}
StringItem     = _{
    "$" ~ Integer           | // $1, $a
    "$" ~ namepath          | // $1, $a
    "${" ~ expression ~ "}" | // ${a}, ${1 + 1}
    StringUnicode           | // \u{20}
    StringEscape
}
StringEscape  =@{"\\" ~ any}
StringUnicode = @{"\\u" ~ "{" ~ASCII_ALPHANUMERIC* ~ "}"}
XmlEscaped    = @{AND ~ ASCII_ALPHANUMERIC+ ~ Semicolon}
Quotation     = _{"\""}
Apostrophe    = _{"'"}
any           = @{ANY}
/*====================================================================================================================*/
///#61AFEF
Symbol   = ${SYMBOL_XID|SYMBOL_ESCAPE}
namepath = ${Symbol ~ (Proportion ~ Symbol)*}
freepath = ${Symbol ~ ((Proportion|DOT) ~ Symbol)*}
///
SYMBOL_XID = @{(XID_START|Underline) ~  XID_CONTINUE*}
///
SYMBOL_ESCAPE = @{Quote ~ (!Quote ~ ANY)+ ~ Quote}
Quote =@{"`"}
/*====================================================================================================================*/
//#7F848E
WHITESPACE = _{NEWLINE|WHITE_SPACE}
COMMENT    =  {CommentN|Comment1}
Comment1   = @{Tilde ~ (!NEWLINE ~ ANY)* }
CommentN   = @{PUSH(Tilde{3,}) ~ (!(Tilde ~ PEEK) ~ ANY)* ~ POP}
Tilde      = @{"~"}
/*====================================================================================================================*/
Proportion = _{"::"|"∷"} //U+2237
Comma      = _{","} //U+FF0C
Colon      = _{":"} //U+FF1A
Semicolon  = _{";"}
Separate   = _{";;"}
//!Orange: Modifier
// Keywords = !{If|For}
Modifier = !{(!(Symbol~(DOT|Set|Comma|Colon|Semicolon|"{"|"}"|"("|")"|"<"|">")) ~Symbol)}
//!#56B6C2: Prefix|Infix|Postfix
Prefix = @{
    (Bang|ADD|SUB|Star)
}
Suffix = @{
    DoubleBang
  | (Bang | RAISE)
}
Infix = _{
    Set
  | (CONCAT|REMOVE)
  | (LOGIC_AND|LOGIC_OR)
  | (ADD|SUB)
  | (Multiply|CenterDot|Kronecker|TensorProduct|Divide|Quotient|Modulo)
  | Power
  | (Grater|GraterEqual|Equal)
  //| Dot
}

CONCAT = @{"++"}
REMOVE = @{"--"}

ADD = @{"+"}
SUB = @{"-"}

AND = @{"&"}
Or  = @{"|"}

LOGIC_AND = @{"||"|"∧"}
LOGIC_OR  = @{"&&"|"∨"}


Star =@{"*"}
Slash =@{"/"}
Solidus = @{"\\"}

DOT = @{"."}
///#56B6C2
RAISE = @{"?"}

Load =@{"<<<"|"⋘"} //U+22D8
Save =@{">>>"|"⋙"} //U+22D9
LeftShift =@{"<<"|"≪"} //U+226A
RightShift =@{">>"|"≫"} //U+226B
LessEqual =@{"<="}
GraterEqual =@{">="}
Less =@{"<"}
Grater =@{">"}



Equivalent =@{"==="}
NotEquivalent =@{"=!="}
Equal =@{"=="}
NotEqual =@{"!="|"≠"} //U+2260
///#56B6C2
Set = @{"="}



Multiply =@{Star | "×"} //U+00D7
CenterDot = @{"⋅"} //U+22C5
Kronecker =@{"⊗"} //U+2297
TensorProduct=@{"⊙"} //U+2299
Divide = @{Slash | "÷"} //U+00F7
Quotient = @{"//"}
Modulo = @{"%"}


Power = @{"^"}
Surd = @{"√"} //U+221A





To =@{"->"}
Elvis =@{":?"}



LogicNot =@{"¬"} //U+00AC
LogicXor =@{"⊕"} //U+2295

Ellipsis =@{"..."|"…"} // U+2026

Output =@{"%%"}


DoubleBang =@{"!!"}
Bang =@{"!"}

